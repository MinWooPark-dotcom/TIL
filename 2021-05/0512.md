# Today I Learned

매일 배운 것을 정리하며 기록합니다.
『HTTP 완벽 가이드』를 통해 공부했던 내용들을 복습하고 정리하려고 합니다.

---

# I. HTTP: 웹의 기초

## 03. HTTP 메시지

### 메시지의 흐름

#### 메시지는 원 서버 방향을 인바운드로 하여 송신

![](https://images.velog.io/images/qmasem/post/bb942d1f-0054-4450-a240-8f2438fbe67d/image.png)

트랜잭션 방향을 표현하기 위해 HTTP는 인바운드와 아웃바운드라는 용어를 사용합니다.

메시지가 **원 서버로 향하는 것은 인바운드로 이동**하는 것이고, 모든 처리가 끝난 뒤에 메시지가 **사용자 에이전트로 돌아오는 것은 아웃바운드로 이동**하는 것입니다.

---

#### 다운스트림(Downstream)

![](https://images.velog.io/images/qmasem/post/5a4fd1ba-d43f-4263-a97b-a5983ed324e1/image.png)

HTTP 메시지는 강물과 같이 흐릅니다.
요청, 응답에 관계없이 모든 메시지는 **다운스트림**으로 흐릅니다.

메시지 발송자는 수신자의 업스트림입니다.

클라이언트에서 서버로 요청을 보내면 **클라이언트는 업스트림이므로 서버로 향합니다**.

마찬가지로 서버에서 클라이언트로 응답을 보내면 **서버가 업스트림이므로 클라이언트로 향합니다**.

---

#### 메시지의 각 부분

![](https://images.velog.io/images/qmasem/post/faba34a0-67e1-4d25-8aa8-d2e856e71732/image.png)

HTTP 메시지는 클라이언트로부터의 **요청**이나 서버로부터의 **응답** 중 하나를 포함합니다.

메시지는 **시작줄**, **헤더 블록**, **본문** 이렇게 세 부분으로 이루어집니다.

시작줄은 이것이 **어떤 메시지**인지 서술하며, 헤더 블록은 **속성**을, 본문은 **데이터**를 담고 있습니다.

---

#### 메시지 문법

![](https://images.velog.io/images/qmasem/post/a7525b5d-6d42-4a2d-99f9-f4b2c0f80291/image.png)

요청 메시지는 **웹 서버에 어떤 동작을 요구**합니다.
응답 메시지는 **요청의 결과를 클라이언트에게** 돌려줍니다.

요청과 응답 메시지 모두 기본적으로 구조는 같습니다.
시작줄에서만 문법이 다릅니다.

> 요청 메시지의 형식
> <메서드> <요청 URL> <버전>
> <헤더>
> (개행)
> <엔티티 본문>

> 응답 메시지의 형식
> <버전> <상태 코드> <사유 구절>
> <헤더>
> (개행)
> <엔티티 본문>

메서드는 클라이언트 측에서 **서버가 리소스에 대해 수행해주길 바라는 동작**입니다.

요청 URL은 **리소스를 지칭**하는 완전한 URL 혹은 URL의 경로 구성요소입니다.

완전한 URL이 아니더라도 클라이언트가 서버와 직접 대화하고 있고 경로 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없습니다.

서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 것이기 때문입니다.

버전은 HTTP의 버전을 말합니다.
형식은 다음과 같습니다.

> HTTP/<메이저>,<마이너>

상태코드는 요청 중에 **무엇이 일어났는지 설명**하는 세 자리 숫자입니다.
각 코드의 첫 번째 자릿수는 상태의 일반적인 분류('성공', '에러'등)를 나타냅니다.

사유 구절(reason-phrase)는 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구입니다.
상태코드가 같다면 사유 구절은 달라도 같은 상태코드의 의미로 처리되어야 합니다.

> ex) '200 OK' 와 '200 NOT OK'는 동등하게 성공을 의미하는 것으로 처리되어야 함.

헤더들은 이름, 콜론(:), 선택적인 공백 값, 빈 줄(CRLF)이 순서대로 나타납니다.
특정 HTTP 버전은 어떤 특정 헤더가 포함 되어야만 유효한 것으로 간주하기도 합니다.

엔티티 본문은 임의 데이터 블록을 포함합니다.
모든 메시지가 본문을 가지는 것이 아니기 때문에 때때로 CRLF로 끝나게 됩니다.

![](https://images.velog.io/images/qmasem/post/607ca648-23ff-445b-9f01-48587c42473f/image.png)

---

### 시작줄

모든 HTTP 메시지는 시작줄로 시작합니다.

요청 메시지의 시작줄은 **무엇을 해야 하는지** 말해줍니다.

응답 메세지의 시작줄은 **무슨 일이 일어났는지** 말해줍니다.

#### 요청 메시지의 시작줄(요청줄)

서버에서 어떤 동작이 일어나야 하는지 설명해주는 **메서드**와 그 동작에 대한 대상을 지칭하는 **요청 URL**, 클라이언트가 어떤 **HTTP 버전**으로 말하고 있는지 포함합니다.

이 모든 필드는 공백으로 구분됩니다.

---

#### 응답 메시지의 시작줄(응답줄)

응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줍니다.
응답 메시지에서 쓰인 **HTTP의 버전**과 **상태 코드**, **사유 구절**이 들어갑니다.

마찬가지로 이 모든 필드는 공백으로 구분됩니다.

---

#### 메서드

MDN에서 자주 쓰이는 메서드 몇 개만 가져왔습니다.

> - GET
>   GET 메서드는 특정 리소스의 표시를 요청합니다. GET을 사용하는 요청은 오직 데이터를 받기만 합니다.

> - HEAD
>   HEAD 메서드는 GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.

> - POST

    POST 메서드는 특정 리소스에 엔티티를 제출할 때 쓰입니다. 이는 종종 서버의 상태의 변화나 부작용을 일으킵니다.

> - PUT

    PUT 메서드는 목적 리소스 모든 현재 표시를 요청 payload로 바꿉니다.

> - DELETE

    DELETE 메서드는 특정 리소스를 삭제합니다.

> - OPTIONS

    OPTIONS 메서드는 목적 리소스의 통신을 설정하는 데 쓰입니다.

> - PATCH

    PATCH 메서드는 리소스의 부분만을 수정하는 데 쓰입니다.

HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수 있습니다.

이러한 추가 메서드는 HTTP 명세를 확장하는 것이기 때문에 확장 메서드라고 불립니다.

---

#### 상태 코드

상태 코드는 클라이언트에게 **무엇이 일어났는지** 말해줍니다.

상태코드는 100단위로 종류를 구분합니다.

100~199: **정보**

200~299: **성공**

300~399: **리다이렉션**

400~499: **클라이언트 에러**

500~599: **서버 에러**

---

#### 버전 번호

버전 번호는 **HTTP/x.y** 형식으로 요청과 응답 메세지 양쪽 모두에 기술됩니다.

HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 **상대방에게 말해주기 위한 수단**이 됩니다.

HTTP 버전 1.1 애플리케이션과 대화하는 HTTP 버전 1.2 애플리케이션은 1.2 버전의 새로운 기능을 사용할 수 없다는 것을 알아야합니다.

버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가르킵니다.

주의할 점은 HTTP/1.0 애플리케이션이 버전 번호가 HTTP/1.1로 된 응답을 받았을 때, 단지 응답을 보낸 애플리케이션이 HTTP/1.1까지 이해할 수 있음을 의미하는 것입니다.

요청 측에서는 HTTP/1.0까지 지원하기에 1.1버전을 사용한다는 것은 아닙니다.

그리고 버전 번호는 분수로 다루어지지 않습니다.

버전의 각 숫자는 각각 분리된 숫자로 다루어 집니다.

예로 HTTP/2.22는 HTTP/2.3보다 큽니다.

왜냐하면 22가 3보다 크기 때문입니다.

---

#### 헤더

시작줄 다음으로는 헤더가 자리합니다.
HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더합니다.
기본적으로 이름/값 쌍의 목록입니다.

헤더의 문법은 이름, 쉼표, 공백(없어도 됨), 필드 값, CRLF가 순서대로 오는 것입니다.

흔히 쓰이는 헤더의 예는 다음과 같습니다.

> Date: Tue, 3 Oct 1997 02:16:03 GMT (서버가 응답을 만들어 낸 시각)
> Content-length: 15040 (15,040바이트의 데이터를 포함한 엔티티 본문)
> Content-type: image/gif (엔티티 본문은 GIF 이미지)
> Accept: image/gif, image/jpeg, text/html (클라이언트는 GIF, JPEG 이미지와 HTML을 받아들일 수 있음)

---

#### 엔티티 본문

HTTP 메시지의 세 번째 부분은 선택적인 엔티티 본문입니다.
HTTP 메시지의 **화물**이라고 할 수 있습니다.
이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 **여러 종류의 디지털 데이터를 실어 나를 수 있습니다**.

---

### 메서드

#### 안전한 메서드(Safe Method)

HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의합니다.
**GET**과 **HEAD** 메서드는 HTTP 요청의 결과로 **서버에 어떤 작용도 없기에** 안전하다고 할 수 있습니다.

그러나 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없습니다.(개발자에게 달렸기 때문입니다.)

안전한 메서드의 목적은, **서버에 어떤 영향을 줄 수 있는 안전하지 않는 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것**에 있습니다.

---

#### GET

GET는 가장 흔히 쓰이는 메서드입니다.
주로 **서버에게 리소스를 달라고 요청**하기 위해 쓰입니다.
HTTP/1.1은 서버가 GET을 구현할 것을 요구합니다.

---

#### HEAD

HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 **헤더**만 을 돌려줍니다.
엔티티 본문은 반환되지 않습니다.

HEAD를 사용하면 리소스를 가져오지 않고도 리소스에 대한 어느 정도의 정보를 알 수 있고, 상태 코드를 통해 개체가 존재하는지도 알 수 있습니다.
또한 리소스의 변경 유무도 검사할 수 있습니다.

헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 합니다.
그리고 HTTP/1.1 준수를 위해 HEAD 메서드가 반드시 구현되어 있어야 합니다.

---

#### PUT

PUT 메서드는 서버에 문서를 씁니다.
서버는 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해 교체합니다.

PATCH와 PUT 둘 다 수정을 위해 사용하는데 PUT은 전체 수정, 교체를 할 때 사용합니다.

---

#### POST

서버에 입력 데이터를 전송하기 위해 설계되었습니다.

---

#### TRACE

클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줍니다.
주로 진단을 위해 사용됩니다.

---

#### OPTIONS

서버에게 여러 가지 종류의 지원 범위에 대해 물어봅니다.
서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있습니다.

---

#### DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청합니다.

---

#### 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있습니다.

만약 확장 메서드를 정의한다면, 대부분의 HTTP 어플리케이션이 이해할 수 없을 겁니다.

마찬가지로 저의 HTTP 애플리케이션이 이해할 수 없는 확장 메서드를 사용하는 애플리케이션과 마주칠 수도 있습니다.

이런 상황에서는 확장 메서드에 대해 관용적인 것이 좋다고 합니다.

종단 간(end-to-end) 행위를 망가뜨리지 않을 수 있다면, 알려지지 않은 메서드가 담긴 메시지를 다운스트림 서버로 전달하려고 시도하는 게 낫다고 합니다.

그렇지 않다면 프락시는 501 Not Implemented 상태 코드로 응답해야 합니다.

확장 메서드를 다룰 때는 "엄격하게 보내고 관대하게 받아들여라"라는 오랜 규칙을 따르는 것이 가장 좋다고 합니다.

(5/12 완료)

---

### 상태 코드

업데이트 예정

---

Reference :

데이빗 고을리, 브라이언 토티, 마조리 세이어, 세일루 레디, 안슈 아가왈, 『HTTP 완벽 가이드』, 프로그래밍 인사이트 (2014), p49-84.

[MDN - HTTP 요청 메서드](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)
